#include "cac.h"

#include "md5sum.cpp"

// ----- convertors ----------------------------------------------------------
char accomplys2DebtorStatus(const char *accomplys)
{
	char debtorStatus = '\0';

	if (any(accomplys))
	{
		const char *s = accomplys;

		debtorStatus = DEBTOR_STATUS_INVALID;

		do
		{
			Accomply->Seek(*s);

			if (debtorStatus == DEBTOR_STATUS_INVALID)
				debtorStatus = Accomply->debtorStatus;
			else if (Accomply->debtorStatus != debtorStatus)
			{
				debtorStatus = '\0';
				break;
			}
		} while (*++s);
	}

	return debtorStatus;
}

void Composition2Group(TGroup *group, char college, long composition, bool clear, bool secretar)
{
	static constant names[] = { "F_JUDGE", "F_SECRETAR", "F_JUDGE_X", "F_REJUDGE_X", "F_PRESIDENT", NULL };

	FineComposition->college = college;
	FineComposition->Seek(composition);

	for (constant *name = names; *name; name++)
	{
		TStringAlias *field = (TStringAlias *) group->Find(*name);

		if (field && !atob(field->S()) && (strcmp(*name, "F_SECRETAR") || secretar))
		{
			const char *s = ((TString *) FineComposition->Find(*name))->S();

			if (atob(s))
				field->SetS(s);
			else if (clear)
				field->SetS(EMPTY);
		}
	}
}

TSideWind *Container2SideWind(TRCDKeyContainer *container)
{
	// 2004:052 BUGFIX: KIND_DECISIONS -> KIND_ENDOCS
	TSideWind *sideWind = strchr(KIND_ENDOCS, container->kind) && ((TDecision *) container)->PersonalData() ?
		new TJudgement : new TSideWind;

	sideWind->kind = container->kind;
	return sideWind;
}

const TContainerSched ContainerScheds[] =
{
	// 2002:337 LRQ: Comout all punishment scheds; 2003:057 LRQ: Uncomout
	// 2003:064 +DPREPARE; 2003:065 +SCHED_FCHANGE
	// 2003:066 +SCHED_FREGISTER
#if COURT_TYPE == COURT_APPEAL
	{ KIND_PUNISHMENT_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_PUNISHMENT_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_PUNISHMENT_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_PUNISHMENT_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_PUNISHMENT_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_30 },
	{ KIND_PUNISHMENT_LAWS, KIND_JUDGEMENTS, RESULT_WITH_JUDGEMENT, SCHED_JUDGEMENT },

	{ KIND_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_CITIZEN_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_30 },
	{ KIND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_14 },
	{ KIND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_CITIZEN_LAWS, KIND_AGAINST_APPROTS, RESULT_INSEND, SCHED_REP_REPROT },

	// 2007:265 copied from CITIZEN, LRQ confirmed
	{ KIND_RECITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_RECITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_RECITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_RECITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_RECITIZEN_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_RECITIZEN_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_RECITIZEN_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_RECITIZEN_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_30 },
	{ KIND_RECITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_14 },
	{ KIND_RECITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_RECITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_RECITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_RECITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_RECITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_RECITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_RECITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_RECITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_RECITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },

	// 2004:169 ACT: copied from citizen
	{ KIND_TRADE_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_TRADE_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_TRADE_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_TRADE_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_TRADE_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_TRADE_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_TRADE_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_TRADE_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_30 },
	{ KIND_TRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_14 },
	{ KIND_TRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_TRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_TRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_TRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_TRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_TRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_TRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_TRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_TRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_TRADE_LAWS, KIND_AGAINST_APPROTS, RESULT_INSEND, SCHED_REP_REPROT },

	// 2007:265 copied from TRADE, LRQ confirmed
	{ KIND_RETRADE_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_RETRADE_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_RETRADE_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_RETRADE_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_RETRADE_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_RETRADE_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_RETRADE_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_RETRADE_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_30 },
	{ KIND_RETRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_14 },
	{ KIND_RETRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_RETRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_RETRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_RETRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_RETRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_RETRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_RETRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_RETRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_RETRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
#endif  // APPEAL
#if COURT_TYPE == COURT_ADMIN
	{ KIND_1ST_ADMIN_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_1ST_ADMIN_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_1ST_ADMIN_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_1ST_ADMIN_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_1ST_ADMIN_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_1ST_ADMIN_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_1ST_ADMIN_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_1ST_ADMIN_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_14 },
	{ KIND_1ST_ADMIN_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_14 },
	{ KIND_1ST_ADMIN_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_ADMIN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_ADMIN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_ADMIN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_1ST_ADMIN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_1ST_ADMIN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_ADMIN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_ADMIN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_ADMIN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },

	{ KIND_2ND_ADMIN_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_2ND_ADMIN_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_2ND_ADMIN_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_2ND_ADMIN_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	// 2002:147 LRQ: Uncommented
	{ KIND_2ND_ADMIN_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },

	// 2008:296 copyed from 1ST_ADMIN
	{ KIND_1ST_TRICKY_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_1ST_TRICKY_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_1ST_TRICKY_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_1ST_TRICKY_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_1ST_TRICKY_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_1ST_TRICKY_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_1ST_TRICKY_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_1ST_TRICKY_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_14 },
	{ KIND_1ST_TRICKY_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_14 },
	{ KIND_1ST_TRICKY_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_TRICKY_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_TRICKY_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_TRICKY_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_1ST_TRICKY_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_1ST_TRICKY_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_TRICKY_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_TRICKY_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_TRICKY_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },

	// 2007:134 copied from 2ND_ADMIN
	{ KIND_2ND_TRICKY_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_2ND_TRICKY_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_2ND_TRICKY_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_2ND_TRICKY_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_2ND_TRICKY_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },

	// 2007:134 copied from 1ST_ADMIN
	{ KIND_1ST_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_1ST_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_1ST_CITIZEN_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_14 },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_14 },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
#endif  // ADMIN
#if COURT_TYPE == COURT_AREAL
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_14 },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_JUDGEMENTS, RESULT_WITH_JUDGEMENT, SCHED_JUDGEMENT },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_0E },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	// 2003:083 BUGFIX: SCHED_INSEND_7 -> SCHED_INSEND_07
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_07 },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },

	// 2002:336 Only SCHED_FIXED for KIND_2ND_ADMIN_PUNISHMENT_LAWS
	{ KIND_2ND_PUNISHMENT_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_30 },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_JUDGEMENTS, RESULT_WITH_JUDGEMENT, SCHED_JUDGEMENT },
	// 2003:093 BUGFIX? were missing
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_0E },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_07 },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },

	{ KIND_1ST_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_1ST_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_1ST_CITIZEN_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_14 },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_7 },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	// 2009:216 +other copies
	{ KIND_1ST_CITIZEN_LAWS, KIND_CLOSED_SESSIONS, RESULT_SUB_SETTLEMENT, SCHED_REP_INDOC },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CLOSED_SESSIONS, RESULT_WITH_ORDER, SCHED_REP_INDOC },
	{ KIND_1ST_CITIZEN_LAWS, KIND_AGAINST_APPEALS, RESULT_INSEND, SCHED_REP_REAPP },
	{ KIND_1ST_CITIZEN_LAWS, KIND_INREG_RESCINDS, RESULT_INSEND, SCHED_REP_REREJ },

	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_14 },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_07 },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	// 2009:216 +other copies
	{ KIND_2ND_CITIZEN_LAWS, KIND_AGAINST_APPROTS, RESULT_INSEND, SCHED_REP_REPROT },

	{ KIND_1ST_TRADE_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_1ST_TRADE_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_1ST_TRADE_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_1ST_TRADE_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_1ST_TRADE_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_1ST_TRADE_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_1ST_TRADE_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_1ST_TRADE_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_14 },
	{ KIND_1ST_TRADE_LAWS, KIND_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_7 },
	{ KIND_1ST_TRADE_LAWS, KIND_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_TRADE_LAWS, KIND_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_TRADE_LAWS, KIND_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_TRADE_LAWS, KIND_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_1ST_TRADE_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_1ST_TRADE_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_TRADE_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_TRADE_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_TRADE_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_1ST_TRADE_LAWS, KIND_CLOSED_SESSIONS, RESULT_SUB_SETTLEMENT, SCHED_REP_INDOC },
	{ KIND_1ST_TRADE_LAWS, KIND_CLOSED_SESSIONS, RESULT_WITH_ORDER, SCHED_REP_INDOC },
	{ KIND_1ST_TRADE_LAWS, KIND_AGAINST_APPEALS, RESULT_INSEND, SCHED_REP_REAPP },
	{ KIND_1ST_TRADE_LAWS, KIND_INREG_RESCINDS, RESULT_INSEND, SCHED_REP_REREJ },

	{ KIND_FIRM_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_FIRM_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_FIRM_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_FIRM_LAWS, KIND_SESSIONS, RESULT_WITH_ORDER, SCHED_HOLD },	// 2002:288 LRQ
	{ KIND_FIRM_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_FIRM_LAWS, KIND_SESSIONS, RESULT_CANCEL_REGISTER, SCHED_DREGISTER },
	{ KIND_FIRM_LAWS, KIND_SESSIONS, RESULT_CANCEL_CHANGE, SCHED_DCHANGE },
	{ KIND_FIRM_LAWS, KIND_DECISIONS, RESULT_DENY_REGISTER, SCHED_BREGISTER },
	{ KIND_FIRM_LAWS, KIND_DECISIONS, RESULT_DENY_CHANGE, SCHED_BCHANGE },
	{ KIND_FIRM_LAWS, KIND_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_FIRM_LAWS, KIND_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_FIRM_LAWS, KIND_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_FIRM_LAWS, KIND_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_FIRM_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_FIRM_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_FIRM_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_FIRM_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_FIRM_LAWS, C2S[KIND_CHANGE_SURROUND], RESULT_NEW, SCHED_FCHANGE },
	{ KIND_FIRM_LAWS, KIND_FIRM_LAWS, RESULT_NEW, SCHED_FREGISTER },

	{ KIND_2ND_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_2ND_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_2ND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_2ND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_2ND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_2ND_CITIZEN_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_30 },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_14 },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },

	{ KIND_2ND_TRADE_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_2ND_TRADE_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_2ND_TRADE_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_2ND_TRADE_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_2ND_TRADE_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_2ND_TRADE_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_2ND_TRADE_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_2ND_TRADE_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_30 },
	{ KIND_2ND_TRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_14 },
	{ KIND_2ND_TRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_TRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_TRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_TRADE_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_2ND_TRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_2ND_TRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_TRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_TRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_TRADE_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_2ND_TRADE_LAWS, KIND_AGAINST_APPEALS, RESULT_INSEND, SCHED_REP_REAPP },

	{ KIND_1ST_ADMIN_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_1ST_ADMIN_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_1ST_ADMIN_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_1ST_ADMIN_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_1ST_ADMIN_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_1ST_ADMIN_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_1ST_ADMIN_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_1ST_ADMIN_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_14 },
	{ KIND_1ST_ADMIN_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_14 },
	{ KIND_1ST_ADMIN_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_ADMIN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_ADMIN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_ADMIN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_1ST_ADMIN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_1ST_ADMIN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_ADMIN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_ADMIN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_ADMIN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },

	{ KIND_2ND_ADMIN_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_2ND_ADMIN_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_2ND_ADMIN_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_2ND_ADMIN_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	// 2002:147 LRQ: Uncommented
	{ KIND_2ND_ADMIN_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
#endif  // AREAL
#if COURT_TYPE == COURT_MILITARY
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_14 },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_JUDGEMENTS, RESULT_WITH_JUDGEMENT, SCHED_JUDGEMENT },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_0E },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_07 },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },

	{ KIND_2ND_PUNISHMENT_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_30 },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_JUDGEMENTS, RESULT_WITH_JUDGEMENT, SCHED_JUDGEMENT },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_0E },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_07 },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_NONADM_PUNISHMENT_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },

	{ KIND_1ST_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_1ST_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_1ST_CITIZEN_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_1ST_CITIZEN_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_14 },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_7 },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_1ST_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },

	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_14 },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_07 },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },

	{ KIND_2ND_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_2ND_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_2ND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_2ND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_2ND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_2ND_CITIZEN_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_30 },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_14 },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_CITIZEN_LAWS, KIND_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_2ND_CITIZEN_LAWS, KIND_PRIVATE_CONNECT_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
#endif  // MILITARY
#if COURT_TYPE == COURT_REGIONAL
	// 2004:138 LRQ: same as AREA 1ST inst, allow_sched_*() differ
	{ KIND_PUNISHMENT_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_PUNISHMENT_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_PUNISHMENT_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_PUNISHMENT_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_PUNISHMENT_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_14 },
	{ KIND_PUNISHMENT_LAWS, KIND_JUDGEMENTS, RESULT_WITH_JUDGEMENT, SCHED_JUDGEMENT },
	{ KIND_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_0E },
	{ KIND_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_PUNISHMENT_LAWS, KIND_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_07 },
	{ KIND_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_PUNISHMENT_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },

	{ KIND_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_CITIZEN_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_CITIZEN_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_CITIZEN_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_14 },
	{ KIND_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_7 },
	{ KIND_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_CITIZEN_LAWS, KIND_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_CITIZEN_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_CITIZEN_LAWS, KIND_CLOSED_SESSIONS, RESULT_SUB_SETTLEMENT, SCHED_REP_INDOC },
	{ KIND_CITIZEN_LAWS, KIND_CLOSED_SESSIONS, RESULT_WITH_ORDER, SCHED_REP_INDOC },
	{ KIND_CITIZEN_LAWS, KIND_AGAINST_APPEALS, RESULT_INSEND, SCHED_REP_REAPP },
	{ KIND_CITIZEN_LAWS, KIND_INREG_RESCINDS, RESULT_INSEND, SCHED_REP_REREJ },

	{ KIND_MARRIAGE_LAWS, KIND_OPEN_SESSIONS, RESULT_FIXED, SCHED_FIXED },
	{ KIND_MARRIAGE_LAWS, KIND_OPEN_SESSIONS, RESULT_PUBLIC_DECISION, SCHED_DPREPARE },
	{ KIND_MARRIAGE_LAWS, KIND_SESSIONS, RESULT_HOLD_SETT, SCHED_HOLD },
	{ KIND_MARRIAGE_LAWS, KIND_SESSIONS, RESULT_HOLD_ORD, SCHED_HOLD },
	{ KIND_MARRIAGE_LAWS, KIND_SESSIONS, RESULT_STOPPED, SCHED_STOPPED },
	{ KIND_MARRIAGE_LAWS, KIND_SESSIONS, RESULT_CANCELED, SCHED_CANCELED },
	{ KIND_MARRIAGE_LAWS, KIND_SESSIONS, RESULT_WITH_SETTLEMENT, SCHED_SETTLE_7 },
	{ KIND_MARRIAGE_LAWS, KIND_DECISIONS, RESULT_NULL, SCHED_DECIDE_14 },
	{ KIND_MARRIAGE_LAWS, KIND_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_7 },
	{ KIND_MARRIAGE_LAWS, KIND_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_MARRIAGE_LAWS, KIND_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_MARRIAGE_LAWS, KIND_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_MARRIAGE_LAWS, KIND_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_MARRIAGE_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INSEND, SCHED_INSEND_3 },
	{ KIND_MARRIAGE_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INHOLD, SCHED_INHOLD },
	{ KIND_MARRIAGE_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETOUT, SCHED_INRET_OUT },
	{ KIND_MARRIAGE_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETINV, SCHED_INRET_INV },
	{ KIND_MARRIAGE_LAWS, KIND_PRIVATE_CALL_APPROTS, RESULT_INRETBAD, SCHED_INRET_BAD },
	{ KIND_MARRIAGE_LAWS, KIND_CLOSED_SESSIONS, RESULT_SUB_SETTLEMENT, SCHED_REP_INDOC },
	{ KIND_MARRIAGE_LAWS, KIND_CLOSED_SESSIONS, RESULT_WITH_ORDER, SCHED_REP_INDOC },
	{ KIND_MARRIAGE_LAWS, KIND_AGAINST_APPEALS, RESULT_INSEND, SCHED_REP_REAPP },
	{ KIND_MARRIAGE_LAWS, KIND_INREG_RESCINDS, RESULT_INSEND, SCHED_REP_REREJ },
#endif  // REGIONAL
	{ NULL, NULL, RESULT_NULL, SCHED_FAKE }
};

char get_schedule_kind(const TRCDKeyContainer *container)
{
	char scheduleKind = container->kind;

	if (strchr(KIND_INREG_EVENTS, scheduleKind) || scheduleKind == KIND_REQUEST_RESOLUTION)
	{
		TRCDKeyContainer *tContainer = type2RCDKeyContainer(container->key.type);

		tContainer->key = container->key;

		if (tContainer->Get("F_KIND"))
			scheduleKind = tContainer->kind;

		delete tContainer;
	}

	return scheduleKind;
}

char Container2Sched(TRCDKeyContainer *container, char result)
{
	char scheduleKind = get_schedule_kind(container);
	char originKind, secondKind;
	const TContainerSched *sched;

	if (!result)
		result = container->Status();

	get_container_kinds(container, originKind, secondKind);

	for (sched = ContainerScheds; sched->originKinds; sched++)
	{
		if (strchr(sched->originKinds, originKind) && strchr(sched->scheduleKinds, scheduleKind) &&
			(!sched->result || sched->result == result))
		{
			break;
		}
	}

	return sched->sched;
}

const CDate &container_event_date1(const TRCDKeyContainer* container)
{
	TDate *date;

	if (container->key.type == TYPE_OUTREG && ((TOutReg *) container)->aret)
		date = (TDate *) container->Find("F_RETURNED");
	else
		date = (TDate *) container->Find("F_FROM_DATE");

	return date ? date->Date() : container->date;
}

static char container_to_law_type(TRCDKeyContainer* container, const bool errMsg = true)
{
	char lawType = TYPE_NULL;
	TChar *lawsuitType = (TChar *) container->Find("F_LAWSUIT_TYPE");
	char lawKind;

	if (!lawsuitType || lawsuitType->C())
	{
		if (strchr(TYPE_LAWSUITS, container->key.type))
			lawType = container->key.type;
		else if (lawsuitType && strchr(TYPE_LAWSUITS, lawsuitType->C()))
			lawType = lawsuitType->C();
		else if ((lawKind = container_to_law_kind(container, errMsg)) != KIND_NULL)
			lawType = kind2type(lawKind);
	}
	else if (errMsg)
		error("%d/%ld/%ld: empty law_type", container->key.type, container->key.no, container->key.year);

	return lawType;
}

char container_to_law_kind(TRCDKeyContainer* container, const bool errMsg)
{
	char originKind, secondKind;

	get_container_kinds(container, originKind, secondKind);

	if (originKind == KIND_V_LAWSUIT)
	{
		if (errMsg)
			error("%d/%d: container_to_law_kind failed", container->key.type, container->kind);
		secondKind = KIND_NULL;
	}

	return lawsuit_kind_from(originKind, secondKind);
}

int find_person(TGroupArray *persons, const char *opt_person)
{
	if (opt_person)
		for (int index = 0; index < persons->Count(); index++)
			if (!strcmp(TYPECHECK_PTR_CAST(TPersonAliasGroup, (*persons)[index])->ucn, opt_person))
				return index;

	return INT_MAX;
}

char inReg2lawType(TInReg *inReg, TRCDKey * const pLawKey, TRCDKey * pReqKey)
{
	char lawType = inReg->lawsuit.type;

	if (lawType == TYPE_REQUEST)
	{
		lawType = container_to_law_type(inReg);
		if (pReqKey)
			*pReqKey = inReg->lawsuit;
	}
	else if (pLawKey)
		*pLawKey = inReg->lawsuit;

	return lawType;
}

int interval2Months(const CDate &start, const CDate &final)
{
	// 2009:096 LRQ/URQ: was + (final.day >= start.day)
	return (final.year * 12 + final.month) - (start.year * 12 + start.month) + (final.day > start.day);
}

static CDate fixup_final(const CDate &final)
{
	CDate fixup = final;

	do fixup += -1; while (!fixup.Work());
	fixup += 1;

	return fixup;
}

char interval2ActAge(const CDate &start, const CDate &final, sign twoMonths)
{
	const int interval = interval2Months(start, fixup_final(final));

	if (twoMonths == -1)
		return interval <= 2 ? AGE_TWO_OR_LESS : AGE_MORE_THAN_TWO;

	if (interval <= 1)
		return AGE_ONE_OR_LESS;

	if (twoMonths && interval <= 2)
		return AGE_ONE_TO_TWO;

	return interval <= 3 ? AGE_ONE_TO_THREE : AGE_MORE_THAN_THREE;
}

int interval2Months(char lawsuitKind, const CDate &start, const CDate &first, const CDate &final)
{
	CDate begin = start;

	if (first >= start && first <= final)
	{
		if (final < IntMinDate || COMPUTE_LAW_AGE == 0)
			begin = first;
	#if COURT_TYPE == COURT_APPEAL || COURT_TYPE == COURT_AREAL || COURT_TYPE == COURT_REGIONAL
		else if (!secondary(lawsuitKind) && final >= IntMaxDate)
			begin = first;
	#endif  // APPEAL || AREAL || REGIONAL
	#if COURT_TYPE == COURT_ADMIN || COURT_TYPE == COURT_MILITARY
		(void) lawsuitKind;
	#endif  // ADMIN || MILITARY
	}

	return interval2Months(begin, fixup_final(final));
}

char interval2LawAge(char lawsuitKind, const CDate &start, const CDate &first, const CDate &final)
{
	const int interval = interval2Months(lawsuitKind, start, first, final);

	switch (interval)
	{
		case 0 :
		case 1 : return AGE_ONE_OR_LESS;
		case 2 :
		case 3 : return AGE_ONE_TO_THREE;
		case 4 :
		case 5 :
		case 6 : return AGE_THREE_TO_SIX;
	}

	return (interval <= 12) ? AGE_SIX_TO_TWELVE : AGE_MORE_THAN_TWELVE;
}

long involvement2assignment(char involvement)
{
	return strchr(INVOLVEMENT_LAWERS, involvement) ? WHAT_LAWYER_ASSIGNMENT : WHAT_PERSON_ASSIGNMENT;
}

char involvement2known(char involvement)
{
#if RANGECHECK
	if (!strchr(INVOLVEMENT_CHECK_PERSONS, involvement))
		fatal("%d: involvement not supported by involvement2known", involvement);
#endif  // RANGECHECK

	if (strchr(INVOLVEMENT_SYNDICS, involvement))
		involvement = INVOLVEMENT_SYNDIC;
	else if (strchr(INVOLVEMENT_EXPERTS, involvement))
		involvement = INVOLVEMENT_EXPERT;
	else if (involvement == INVOLVEMENT_JUROR_SIDE)
		involvement = INVOLVEMENT_JUROR;
	else if (involvement != INVOLVEMENT_EXECUTOR)
		involvement = INVOLVEMENT_LEGALESE;

	return involvement;
}

int keykind2interval(TRCDKey *key, const char kind)
{
	if (kind != KIND_BULWARK)
	{
		TLawsuit lawsuit;

		lawsuit.key = *key;
		// Maybe I shoud return an error for missing lawsuits.
		if (lawsuit.Try())
		{
			//if (strchr(KIND_7_DAY_DOCS, lawsuit.sourceKind))
			//	return 7;
			// 2003:351 LPR: not exact: area '¿' wasn't 7-days
			// 2004:076 LPR: how does it work for appeal, region?
			if (lawsuit.quick & QUICK_QUICK)
				return 7;
			if (strchr(KIND_14_DAY_DOCS, lawsuit.sourceKind))
				return 14;
			if (strchr(KIND_30_DAY_LAWS, lawsuit.kind))
				return 30;
		}
	}

	return 0;
}

static TDatedContainer *kind2DatedContainerLL(const char kind)
{
	TDatedContainer *container = NULL;

	if (strchr(KIND_SESSIONS, kind))
		container = new TSession;
	else if (strchr(KIND_ENDOCS, kind))
		container = new TDecision;
	else if (strchr(KIND_SURROUNDS, kind))
		container = new TSurround;
	else if (strchr(KIND_IN_REG_DOCS, kind))
		container = new TInReg;
	else if (strchr(KIND_OUT_REG_DOCS, kind))
		container = new TOutReg;
	else if (strchr(KIND_MOVEMENTS, kind))
		container = new TMovement;
	else if (strchr(KIND_REQUEST_RESOLUTIONS, kind))
		container = new TRequestResolution;
	else if (strchr(KIND_INREG_EVENTS, kind))
		container = new TInRegEvent;
	else if (strchr(KIND_PROVES, kind))
		container = new TProve;
	else if (strchr(KIND_PROVE_ACTIONS, kind))
		container = new TProveAction;

	if (container)
		container->kind = kind;

	return container;
}

TDatedContainer *kind2DatedContainer(const char kind)
{
	TDatedContainer *container = kind2DatedContainerLL(kind);

	if (!container)
		fatal("%d: kind not supported by kind2DatedContainer", kind);

	return container;
}

TRCDKeyContainer *kind2RCDKeyContainer(const char kind)
{
	TRCDKeyContainer *container = kind2DatedContainerLL(kind);

	if (!container)
	{
		container = type2RCDKeyContainer(kind2type(kind));
		container->kind = kind;
	}

	return container;
}

const char *kind2SurroundmentResults(const char kind)
{
	if (strchr(KIND_DECISIONS, kind))
		return RESULT_SURROUNDMENT_DECS;

	if (strchr(KIND_SETTLEMENTS, kind))
		return RESULT_SURROUNDMENT_SETTS;

	if (strchr(KIND_ORDERS, kind))
		return RESULT_SURROUNDMENT_ORDERS;

	fatal("%d: kind not supported by kind2surroundmentResults", kind);

	return NULL;
}

struct TKind2VisibleKind
{
	const char *kinds;
	char visibleKind;
};

static const TKind2VisibleKind Kind2VisibleKinds[] =
{
	{ KIND_DECISIONS,         KIND_DECISION },
	{ KIND_CLOSED_SESSIONS,   KIND_CLOSED_SESSION },
	{ KIND_INREG_USER_EVENTS, KIND_INREG_USER_EVENT },
	{ NULL, '\0' }
};

char kind2VisibleKind(const char kind)
{
	for (const TKind2VisibleKind *kk = Kind2VisibleKinds; kk->kinds; kk++)
		if (strchr(kk->kinds, kind))
			return kk->visibleKind;

	return kind;
}

void kind2involvements(const char kind, mstr &involvements)
{
	Kind->Seek(kind);
	involvements.cat(Kind->suitors);
	involvements.cat(Kind->defendants);
	involvements.cat(Kind->others);
}

char index2kind(int index, const char *kinds)
{
	if (index <= 0 || index > strlen(kinds))
		return KIND_NULL;

	return kinds[index - 1];
}

int kind2index(char kind, const char *kinds)
{
	if (strchr(kinds, kind) == NULL)
		return 0;

	return strchr(kinds, kind) - kinds + 1;
}

char origin2LawsuitKind(const TRCDKey &origin, bool complain)
{
	TOriginContainer *const container = (TOriginContainer *) type2RCDKeyContainer(origin.type);
	TVirtPtr VP(container);
	char kind = '\0';

	container->key = origin;
	const char *field = container->key.type == TYPE_REQUEST ? "F_LAW_KIND" : "F_KIND";

	if (complain ? container->Get(field) : container->Try(field))
		kind = container->LawKind();

	return kind;
}

#if TESTVER
static bool lsettoerr(const char *name, const char *format, ...)
{
	if (name)
	{
		va_list ap;

		va_start(ap, format);
		vmessage(MB_ERROR, format, ap);
		va_end(ap);
		failure();
	}

	return false;
}

bool strvalue_to_lset(const char *value, TIntegerArray *lset, const char *name)
{
	int n;
	const char *s = value;
	long l;

	for (;;)
	{
		if (sscanf(s, "%ld%n", &l, &n) != 1)
			return lsettoerr(name, "%s: value expected in %s", name, value);

		s += n;

		if (l == -1)
			l = COURT_EISPP;
		else if (!strncmp(s, "...", 3))
		{
			long l2;

			s += 3;

			if (sscanf(s, "%ld%n", &l2, &n) != 1)
				return lsettoerr(name, "%s: ...value missing in %s", name, value);

			s += n;

			if (abs(l2 - l) > 1000)
				return lsettoerr(name, "%ld...%ld: range too big in %s", l, l2, name);

			if (l > l2)
				return lsettoerr(name, "%ld...%ld: negative range in %s", l, l2, name);

			while (l < l2)
				lset->Add(l++);
		}

		lset->Add(l);

		if (lset->Count() > SHRT_MAX)
			return lsettoerr(name, "%s: too many elements", name, value);

		if (*s == ',')
			s++;
		else if (!any(s))
			break;
	}

	return true;
}
#else  // TESTVER
bool strvalue_to_lset(const char *value, TIntegerArray *lset, const char *name)
{
	int n;
	const char *s = value;
	long l;

	for (;;)
	{
		if (sscanf(s, "%ld%n", &l, &n) != 1)
		{
			if (name)
				fatal("%s: value expected in %s", name, value);

			return false;
		}

		s += n;

		if (l == -1)
			l = COURT_EISPP;
		else if (!strncmp(s, "...", 3))
		{
			long l2;

			s += 3;
			if (sscanf(s, "%ld%n", &l2, &n) != 1)
			{
				if (name)
					fatal("%s: ...value missing in %s", name, value);

				return false;
			}

			s += n;
		#if RANGECHECK
			if (abs(l2 - l) > 1000)
			{
				if (name)
					fatal("%ld...%ld: range too big in %s", l, l2, name);

				return false;
			}

			if (l > l2)
			{
				if (name)
					fatal("%ld...%ld: negative range in %s", l, l2, name);

				return false;
			}
		#endif  // RANGECHECK

			while (l < l2)
				lset->Add(l++);
		}

		lset->Add(l);

		if (lset->Count() > SHRT_MAX)
		{
			if (name)
				fatal("%s: too many elements", name, value);

			return false;
		}

		if (*s == ',')
		{
			s++;
			//if (isspace(*s))
			//	s++;
		}
		else if (!any(s))
			break;
	}

	return true;
}
#endif  // TESTVER

void strvalue_to_lranges(const char *value, TIntegerArray &ranges, const char *name)
{
	int n;
	const char *s = value;
	long l;

	for (;;)
	{
		if (sscanf(s, "%ld%n", &l, &n) != 1)
			fatal("%s: value expected in %s", name, value);

		ranges.Add(l);
		s += n;

		if (strncmp(s, "...", 3))
			ranges.Add(l);
		else
		{
			long l2;

			s += 3;

			if (sscanf(s, "%ld%n", &l2, &n) != 1)
				fatal("%s: ...value missing in %s", name, value);

		#if RANGECHECK
			cac_assert(l <= l2);
		#endif  // RANGECHECK

			ranges.Add(l2);
			s += n;
		}

		if (*s == ',')
			s++;
		else if (!any(s))
			break;
	}
}

bool try2decide(const TSession *session, TGroupArray *decisions, const char *kinds, const char *fields)
{
	msql m;

	m.Begin("T_DECISION", fields);
	m.Add(session, "F_NO, F_YEAR, F_TYPE, F_DATE");

	if (kinds)
		m.AddChars("F_KIND", kinds);

	m.AddChar("F_SESSION_KIND", session->kind);
	TQuery q(str(m));

	if (!decisions)
		return q.Read();

	while (q.Read())
	{
		TDecision *decision = new TDecision;

		*decision << q;
		decision->key = session->key;
		decision->date = session->date;
		decisions->Add(decision);
	}

	return decisions->Count();
}

bool try2surround(const TSession *session, TGArray<TSurroundment> *surroundments, const char *fields, const char *kinds,
	bool decisionKinds)
{
	TSurroundment surroundment;
	msql m(surroundment.Name, surroundments || fields ? fields : "F_NO");

	surroundment.SessionCriteria(m, session);

	if (kinds)
		m.AddChars("F_KIND", kinds);

	if (decisionKinds)
		m.AddIsNull("F_DECISION_KIND", false);

	if (surroundments)
		m.AddOrder("F_NO");

	TQuery q(str(m));

	if (!surroundments)
		return q.Read();

	surroundment.LoadArray(surroundments, str(m));
	return surroundments->Count() != 0;
}

bool try2surroundecide(const TSession *session, TGroupArray *decisions)
{
	if (strchr(RESULT_SURROUENDOCS, session->result))
	{
		TGArray<TSurroundment> surrouendocs;
		try2surround(session, &surrouendocs, NULL, KIND_SURROUENDOCS, true);

		for (int i = 0; i < surrouendocs.Count(); i++)
		{
			TDecision *decision = new TDecision;
			decision->Init(surrouendocs[i]);
			decisions->Add(decision);
		}
		// 2016:154 FIX: keep surrouendocs elements
		surrouendocs.Clear();
	}

	return decisions->Count();
}

void fre2surroundecide(TGroupArray *decisions)
{
	for (int i = 0; i < decisions->Count(); i++)
		delete ((TSurroundment *) ((TDecision *) (*decisions)[i])->surrouendoc);
}

char connectKind2Type(char connectKind)
{
#if COURT_TYPE == COURT_ADMIN
	if (connectKind == CONNECT_KIND_CRIME_LAWSUIT)
		return TYPE_TRICKY_LAW;
#endif  // ADMIN
	return CONNECT_KIND_ANNOTYPES[strchr(CONNECT_KIND_ANNOUNCES, connectKind) - CONNECT_KIND_ANNOUNCES];
}

char type2ConnectKind(char type)
{
#if COURT_TYPE == COURT_ADMIN
	if (type == TYPE_TRICKY_LAW)
		return CONNECT_KIND_CRIME_LAWSUIT;
#endif  // ADMIN
	return CONNECT_KIND_ANNOUNCES[strchr(CONNECT_KIND_ANNOTYPES, type) - CONNECT_KIND_ANNOTYPES];
}

TRCDKeyContainer *type2RCDKeyContainer(char type)
{
	TRCDKeyContainer *container;

	switch (type)
	{
		case TYPE_REQUEST : container = new TRequest; break;
		case TYPE_SURROUND : container = new TSurround; break;
		case TYPE_INREG : container = new TInReg; break;
		case TYPE_OUTREG : container = new TOutReg; break;
		case TYPE_PROVE : container = new TProve; break;
		default :
		{
			if (strchr(TYPE_LAWSUITS, type))
				container = new TLawsuit;
			else
				fatal("%d: type not supported by type2RCDKeyContainer", type);
		}
	}

	container->key.type = type;	// 2003:302
	return container;
}

struct TType2SesKinds
{
	char type;
	const char *sesKinds;
};

struct TType2SesKinds Type2SesKinds[] =
{
#if COURT_TYPE == COURT_APPEAL
	{ TYPE_PUNISHMENT_LAW,	KIND_PUNISHMENT_SESS },
	{ TYPE_CITIZEN_LAW,	KIND_CITIZEN_SESS },
	{ TYPE_RECITIZEN_LAW,	KIND_RECITIZEN_SESS },	// 2007:265
	{ TYPE_TRADE_LAW,		KIND_TRADE_SESS },	// 2004:169 ACT:
	{ TYPE_RETRADE_LAW,	KIND_RETRADE_SESS },	// 2007:265
#endif  // APPEAL
#if COURT_TYPE == COURT_ADMIN
	{ TYPE_ADMIN_LAW,		KIND_ADMIN_SESS },
	{ TYPE_TRICKY_LAW,	KIND_TRICKY_SESS },
	{ TYPE_CITIZEN_LAW,	KIND_CITIZEN_SESS },
#endif  // ADMIN
#if COURT_TYPE == COURT_AREAL
	{ TYPE_PUNISHMENT_LAW,	KIND_PUNISHMENT_SESS },
	{ TYPE_CITIZEN_LAW,	KIND_CITIZEN_SESS },
	{ TYPE_TRADE_LAW,		KIND_TRADE_SESS },
	{ TYPE_ADMIN_LAW,		KIND_ADMIN_SESS },
	{ TYPE_FIRM_LAW,		KIND_FIRM_SESS },
#endif  // AREAL
#if COURT_TYPE == COURT_MILITARY
	{ TYPE_PUNISHMENT_LAW,	KIND_PUNISHMENT_SESS },
	{ TYPE_CITIZEN_LAW,	KIND_CITIZEN_SESS },
#endif  // MILITARY
#if COURT_TYPE == COURT_REGIONAL
	{ TYPE_CITIZEN_LAW,	KIND_CITIZEN_SESS },
	{ TYPE_MARRIAGE_LAW,	KIND_MARRIAGE_SESS },
	{ TYPE_PUNISHMENT_LAW,	KIND_PUNISHMENT_SESS },
	{ TYPE_ADMIN_LAW,		KIND_ADMIN_SESS },
#endif  // REGIONAL
	{ TYPE_NULL, NULL }
};

// 2004:169 published for ACT: and others; 2007:265 case types -> array
const char *type2ses_kinds(char type)
{
	TType2SesKinds *t2sk;

	for (t2sk = Type2SesKinds; t2sk->type; t2sk++)
		if (t2sk->type == type)
			break;

	if (!t2sk->sesKinds)
		fatal("%d: type not supported by type2ses_kinds", type);

	return t2sk->sesKinds;
}

const char *kind2ses_kinds(char kind)
{
#if COURT_TYPE == COURT_AREAL || COURT_TYPE == COURT_MILITARY || COURT_TYPE == COURT_REGIONAL
	if (strchr(KIND_PUNISHMENT_LAWS, kind) && kind != KIND_COMMON_PUNISHMENT_LAW)
		return KIND_NOPREORDER_SESS;
#endif  // AREAL || MILITARY || REGIONAL
	return type2ses_kinds(kind2type(kind));
}

#if COURT_TYPE == COURT_REGIONAL
char heritageState2Result(char state)
{
	switch (state)
	{
		case STATE_HERITAGE_ACCEPT : return RESULT_HERITAGE_ACCEPT;
		case STATE_HERITAGE_REJECT : return RESULT_HERITAGE_REJECT;
		case STATE_HERITAGE_LOST : return RESULT_HERITAGE_LOST;
		default: fatal("%d is not a heritage state", state);
	}

	return '\0';
}

char heritageResult2State(char result)
{
	switch (result)
	{
		case RESULT_HERITAGE_ACCEPT : return STATE_HERITAGE_ACCEPT;
		case RESULT_HERITAGE_REJECT : return STATE_HERITAGE_REJECT;
		case RESULT_HERITAGE_LOST : return STATE_HERITAGE_LOST;
		default : return STATE_NONE;
	}
}
#endif  // REGIONAL

bool fileTime2CDate(FILETIME *fileTime, CDate &date)
{
	FILETIME localTime;
	SYSTEMTIME systemTime;

	if (FileTimeToLocalFileTime(fileTime, &localTime) && FileTimeToSystemTime(&localTime, &systemTime))
	{
		date.day = systemTime.wDay;
		date.month = systemTime.wMonth;
		date.year = systemTime.wYear;
		return true;
	}

	return false;
}

// ----- classifiers ---------------------------------------------------------
bool is_suitor_ll(const char kind, char involvement)
{
	// 2009:132 brand-new
	if (TRCDKeyContainer::Other(kind, involvement))
		return false;

	Kind->Seek(kind);
	return strchr(Kind->suitors, involvement) != NULL;
}

bool is_sysadmin()
{
	constant ucn = Default->ucn;
#if TESTVER
	return !strcmp(ucn, SYSAD) || !strcmp(ucn, DZHEK);
#else  // TESTVER
	return !strcmp(ucn, SYSAD);
#endif  // TESTVER
}

bool is_internal(const char *ucn)
{
	return !atob(ucn) || !strcmp(ucn, SYSAD) || !strcmp(ucn, INTER);
}

bool is_real_ucn(char ucnType, const char *ucn)
{
	return ucnType == UCN_CITIZEN_UCN && atof(ucn) >= UCN_VALID_MIN;
}

// ----- access --------------------------------------------------------------
bool can_func(const char func)
{
	return strchr(Default->functions, func) != NULL;
}

bool can_menu(const char menu)
{
	return strchr(Default->menus, menu) != NULL;
}

bool can_admin(const char func)
{
	return is_sysadmin() || (can_menu(RIGHT_ADMIN) && can_func(func));
}

bool can_query()
{
	return strchr(Default->menus, RIGHT_QUERY);
}

static bool mstrorerr(mstr *m, const char *format, ...)
{
	mstr w;
	va_list ap;

	va_start(ap, format);
	w.vprintf(format, ap);
	va_end(ap);

	if (m)
	{
		m->cpy(w);
		return false;
	}

	return error("%s.", str(w));
}

// 2012:068 LPR: +related: removed origin, using lawsuit->key
static bool can_access_lawsuit(TLawsuit *lawsuit, bool write, bool archeck, mstr *m)
{
	if ((lawsuit->flags & LAWSUIT_LIMITED) && !strchr(POST_JUDGES, Default->post))
	{
		if (!strchr(Default->functions, RIGHT_LIMITED))
			return mstrorerr(m, "Íÿìàòå ïðàâî äà ðàáîòèòå ñ äåëà ñ îãðàíè÷åí äîñòúï");

		if (!strchr(Default->xColleges, lawsuit->college))
		{
			return mstrorerr(m, "Íÿìàòå ïðàâî äà ðàáîòèòå ñ äåëà/äîêóìåíòè ñ îãðàíè÷åí äîñòúï îò %s %s.",
				College->Seek(lawsuit->college), COLLEGE);
		}
	}

	if (!strchr(Default->compositions, lawsuit->composition))
	{
		if ((lawsuit->flags & LAWSUIT_LIMITED) && !strchr(POST_JUDGES, Default->post))
		{
			return mstrorerr(m, "Íÿìàòå ïðàâî äà ðàáîòèòå ñ äåëà/äîêóìåíòè ñ îãðàíè÷åí äîñòúï îò %s ñúñòàâ",
				Composition->Seek(lawsuit->composition));
		}

		if (write || !can_func(RIGHT_QALL_COMP))
			return mstrorerr(m, "Íÿìàòå ïðàâî äà ðàáîòèòå ñ äåëà/äîêóìåíòè îò %s ñúñòàâ", Composition->Seek(lawsuit->composition));
	}

	if (archeck)
	{
		TArchive archive;

		if (archive.TryBy(lawsuit, "F_KILL_DATE"))
		{
			mstr w;
			w.printf("%s %ld/%ld å %s", Type->Seek(lawsuit->key.type), lawsuit->key.no, lawsuit->key.year,
				archive.killDate.Empty() ? "àðõèâèðàíî" : "ÓÍÈÙÎÆÅÍÎ");

			if (m)
				m->cpy(w);
			else if (!warn("%s.\n%s", str(w), Q_CONTINUE))
				return false;
		}
	}

	return true;
}

bool can_access_college(char college, bool write)
{
	return strchr(Default->xColleges, college) || (can_func(RIGHT_QALL_COLL) && !write);
}	

bool can_access_exact(const TRCDKeyContainer *container, bool write, bool archeck, mstr *m)
{
	TRCDKey origin;
	TLawsuit lawsuit;

	if (!find_origin(container, origin))
		return false;

	char college = find_college(container, &origin);

	if (!college)
		return false;

	if (!can_access_college(college, write))
		return mstrorerr(m, "Íÿìàòå ïðàâî äà ðàáîòèòå ñ äåëà/äîêóìåíòè îò %s %s", College->Seek(college), COLLEGE);

	lawsuit.college = college;

	if (strchr(TYPE_LAWSUITS, origin.type))
	{
		if (strchr(TYPE_LAWSUITS, container->key.type))
			lawsuit << container;
		else
		{
			lawsuit.key = origin;

			if (!lawsuit.Get("F_FLAGS, F_COMPOSITION"))
				return false;
		}

		return can_access_lawsuit(&lawsuit, write, archeck, m);
	}
	else if (origin.type == TYPE_REQUEST && lawsuit.TryBy(origin, "F_NO, F_YEAR, F_TYPE, F_FLAGS, F_COMPOSITION"))
		return can_access_lawsuit(&lawsuit, write, archeck, m);

	return true;
}

TRCDKeyContainer *can_access_basic(const TRCDKey &key, bool write, bool archeck, mstr *m)
{
	TRCDKeyContainer *container = type2RCDKeyContainer(key.type);
	container->key = key;

	if (key.type != TYPE_EMPTY && (!container->Get() || !can_access_exact(container, write, archeck, m)))
	{
		delete container;
		container = NULL;
	}

	return container;
}

bool can_direct(long flag)
{
	if (flag == 1 && Region->area == DEFAULT_AREA)
		return false;

	if (flag == 2 && Region->area == DEFAULT_AREA && Region->region == DEFAULT_REGION)
		return false;

	return flag <= 2;
}

bool can_direct(long area, long region, long lock)
{
	if (lock == 1 && area == DEFAULT_AREA)
		return false;

	if (lock == 2 && area == DEFAULT_AREA && region == DEFAULT_REGION)
		return false;

	return lock <= 2;
}

bool can_extra_db()
{
	// 2015:334 LRQ: FIX: RIGHT_ATTACH for M-F12 with open extra db
	return ExtraDataBase != NULL && can_func(RIGHT_ATTACH);
}

bool can_portable()
{
	TDoubleExt *ext = Electrics[TYPE_IMAGE].ext;

	for (int i = 0; i < ELECTRIC_EXTS_MAX && any(ext[i].type); i++)
		if (!strcmpi(ext[i].type, PORTABLE_TYPE) || !strcmpi(ext[i].ltype, PORTABLE_TYPE))
			return true;

	return false;
}

bool can_surrouendoc()
{
	return COURT_CODE == COURT_SOFGS || COURT_CODE == COURT_VAROS || COURT_CODE == COURT_DOBOS;
}

bool can_back_date()
{
	return COURT_CODE == COURT_VARAS && Default->post == POST_ADMIN;
}

bool can_extern_sess()
{
	return COURT_CODE == COURT_SOFGS && can_func(RIGHT_EXTERN);
}

// ----- special access ------------------------------------------------------
const char *query_colleges()
{
	return can_func(RIGHT_QALL_COLL) ? COLLEGE_ALLS : Default->colleges;
}

const char *query_compositions()
{
	return can_func(RIGHT_QALL_COMP) ? NULL : Default->compositions;
}

// ----- misc ----------------------------------------------------------------
const char *active_button_text(TGroup *group, long flags)
{
	static constant names[2][2] = { { "Íåàê&òèâåí", "Àê&òèâåí" }, { "À&êòèâèðàíå", "Äåà&êòèâèðàíå" } };
	return names[COURT_CODE == COURT_SOFGS][group && (flags & FLAG_ACTIVE)];
}

void add_side_name(mstr &m, TSideWind *sideWind, const char *sep, bool reNameInitial)
{
	m.sep(sep ? sep : ", ");
	print_side_name(m, sideWind, reNameInitial);
}

bool already_restarted(const TRCDKey &key, bool oldRestart, bool newRestart, const CDate &restartDate)
{
	TLawInterval interval(key, restartDate);
	return newRestart > oldRestart && interval.Try("F_DATE");
}

bool ask_cause(mstr &cause)
{
	return !any(cause) || ask("%s.\n%s", str(cause), Q_CONTINUE);
}

bool ask_college(char lawKind, char college, const char *what)
{
	return kind2type(lawKind) == college ||
		ask("Âíèìàíèå! Ïîëåòî êîëåãèÿ/îòäåëåíèå íå ñúîòâåòñâà íà âèäà íà %s! Æåëàåòå ëè äà ïðîäúëæèòå?", what);
}

static unsigned short crc16(unsigned char *data_p, unsigned char length)
{
	unsigned char x;
	unsigned short crc = 0xFFFF;

	while (length--)
	{
		x = (unsigned char) ((crc >> 8) ^ *data_p++);
		x ^= (unsigned char) (x >> 4);
		crc = (unsigned short) (crc << 8) ^ ((unsigned short) (x << 12)) ^ ((unsigned short) (x << 5)) ^ ((unsigned short) x);
	}

	return crc;
}

static unsigned short barcode_crc(long court, long requestId)
{
	unsigned char block[6];

	*(unsigned short *) block = (unsigned short) court;
	*(unsigned long *) (block + 2) = requestId;
	// should be using real crc10...
	return (unsigned short) (crc16(block, sizeof block) % (36 * 36));
}

#define write36(s, value, len) write3x((s), (value), (len), 36)

void barcode_generate(mstr &m, long requestId, bool asterisk, long court)
{
	char s[SIZE_OF_SUBPOENA_BARCODE - 2];

	*s = '\0';
	write36(s, court, 2);
	write36(s, requestId, requestId >= (36 * 36 * 36 * 36) ? 6 : 4);
	write36(s, barcode_crc(court, requestId), 2);
	strupr(s);

	if (asterisk)
		m.printf("*%s*", s);
	else
		m.cat(s);
}

#define read36(s, len) read3x((s), (len), 36, false)

bool barcode_scan(const char *s, long *court, long *requestId, char *ces)
{
	static constant BAD_CODE = "Íåâàëèäåí áàðêîä èëè íåóñïåøíî ñêàíèðàíå.";

	bool asterisk = *s == '*';
	size_t len = strlen(s);

	if (asterisk)
	{
		if (len == 1 || s[len - 1] != '*')
			return error(BAD_CODE);

		len -= 2;
		s++;
	}

	if (len == LENGTH_OF_CES_BARCODE)
	{
		for (int i = 0; i < len; i++)
			if (!isdigit(s[i]))
				return error(BAD_CODE);

		memcpy(ces, s, LENGTH_OF_CES_BARCODE);
		ces[LENGTH_OF_CES_BARCODE] = '\0';
		return true;
	}

	if (len != LENGTH_OF_SUBPOENA_BARCODE - 2 && len != LENGTH_OF_SUBPOENA_BARCODE - 4)
		return error("Íåâàëèäíà äúëæèíà íà áàðêîäà.");

	*court = read36(s, 2);
	*requestId = read36(s + 2, len - 4);
	long crc = read36(s + len - 2, 2);

	if (*court < 0 || *requestId < 0 || crc < 0 || barcode_crc(*court, *requestId) != crc)
		return error(BAD_CODE);

	if (*court)
	{
		Court->court = *court;
		if (!Court->Try("F_COURT"))
			return error("Áàðêîäà ñúäúðæà íåâàëèäåí íîìåð íà ñúäà.");
	}

	*ces = '\0';
	return true;
}

void write3x(char *s, long value, int len, int radix)
{
	s += strlen(s);

	ltoa(value, s, radix);
	int delta = len - strlen(s);

	if (delta < 0)
		fatal("write3x: %ld: overflow", value);

	strmove(s + delta, s);
	memset(s, '0', delta);
}

long read3x(const char *s, int len, int radix, bool crash)
{
	char buffer[20];
	char *endptr;
	long value;

	if (strlen(s) >= sizeof buffer)
	{
		if (crash)
			fatal("read32: %s: too long", s);

		return -1;
	}

	memcpy(buffer, s, len);
	buffer[len] = '\0';
	value = strtol(buffer, &endptr, radix);

	if (value <= 0 || *endptr)
	{
		if (crash)
			fatal("read32: %s: invalid", buffer);

		return -1;
	}

	return value;
}

const char *blocked_sidewind(TSideWind *sideWind, const char status, bool partial)
{
	if (!isspace(side_wind_notified_mark(sideWind, status)))
		return "çà íåÿ èìà èçïðàòåíè ïðèçîâêè/ñúîáùåíèÿ";

	TExpense expense;
	msql m;

	expense.ImportFields(sideWind, "F_NO, F_YEAR, F_TYPE, F_KIND, F_DATE, F_UCN_TYPE, F_UCN");
	expense.FloatCriteria(m);

	if (partial)
		m.AddChar("F_SUM_TYPE", SUM_TYPE_REWARD);

	TQuery q(str(m));
	if (q.Read())
		return partial ? "çà íåÿ èìà âúâåäåíè âúçíàãðàæäàíèÿ" : "çà íåÿ èìà âúâåäåíè ãëîáè/âúçíàãðàæäàíèÿ";

	return NULL;
}

const char *blocked_sidewind(const TSideWind *sideWind, TGArray<TLinkWind> *links)
{
	for (int i = 0; i < links->Count(); i++)
		if ((*links)[i]->Contains(sideWind))
			return "ó÷àñòâà âúâ âðúçêè";

	return NULL;
}

bool build_ckinds(char *kinds, const char *tKinds, bool write)
{
	char types[SIZE_OF_TYPES];

	build_ctypes(types, TYPE_LAWSUITS, write);
	*kinds = '\0';
	for (const char *s = tKinds; *s; s++)
		if (strchr(types, kind2type(*s)))
			strcach(kinds, *s);

	return any(kinds);
}

bool build_ctypes(char *types, const char *tTypes, bool write)
{
	*types = '\0';
	for (const char *s = tTypes; *s; s++)
		if (
			!strchr(TYPE_LAWSUITS, *s) ||
			strchr(Default->colleges, *s) ||
			(!write && can_func(RIGHT_QALL_COLL))
		)
			strcach(types, *s);

	return any(types);
}

void calc_eispp(const char *value, char *s)
{
	static char EISPP_MULTI[LENGTH_OF_EISPP_MULTI] = { 3, 1, 2, 11, 13, 7, 31, 23, 29, 17, 19, 5 };

	int sum = 0;

	for (int i = 0; i < LENGTH_OF_EISPP_MULTI; i++)
		sum += (isalpha(value[i]) ? strindex(EISPP_LETTERS, value[i]) : value[i] - '0') * EISPP_MULTI[i];

	sum %= 571;

	s[0] = EISPP_LETTERS[sum / 24];
	s[1] = EISPP_LETTERS[sum % 24];
	s[2] = '\0';
}

#define wordptr ((unsigned short *) &resblock)

void calc_final(const char *buffer, char *ptr, const char *ucn, size_t size, char *md5sum)
{
	char resblock[16];

	for (size_t n = ptr - buffer; n < size; n += 2)
	{
		srand(n + ucn[n / 2 % LENGTH_OF_UCN] - '0');
		rand();
		*ptr++ = (char) (rand() & 0xFF);
		rand();
		*ptr++ = (char) (rand() >> 7);
	}

	calc_md5sum(buffer, size, resblock);
	ptr = resblock;

	for (int i = 0; i < 8; i++)
	{
		srand(wordptr[i] ^ wordptr[7 - i]);
		rand();
		*ptr++ = (char) (rand() & 0xFF);
		rand();
		*ptr++ = (char) (rand() >> 7);
	}

	for (int i = 0; i < 16; i++)
		sprintf(md5sum + (i << 1), "%02x", resblock[i]);
}

#undef wordptr

void calc_md5sum(const char *buffer, size_t size, char *resblock)
{
	MD5_CTX context;

	MD5Init(&context);
	MD5Update(&context, buffer, size);
	MD5Final(resblock, &context);
}

void calc_pass(TUser *user, const char *password)
{
	char buffer[36];
	char *ptr = buffer;
	int len = strlen(password);

	memcpy(ptr, password, len);
	ptr += len;
	memcpy(ptr, password, len);
	ptr += len;

	calc_final(buffer, ptr, user->ucn, sizeof buffer, user->md5sum);
}

void camel_case(mstr &m, const char *text, constant *prefixes)
{
	m.cpy(text);
	char *s = ncstr(m);

	if (prefixes)
	{
		for (constant *prefix = prefixes; *prefix; prefix++)
		{
			int len = strlen(*prefix);

			if (!strncmp(s, *prefix, len) && !isalpha(s[len]))
			{
				for (int i = 0; i < len; i++, s++)
					*s = (char) tolower(*s);
				break;
			}
		}
	}

	while (*s)
	{
		if (isalpha(*s))
		{
			while (*++s && isalpha(*s))
				*s = (char) tolower(*s);
		}
		else
			s++;
	}
}

bool check_exists(const char *table, TGroup *group, const char *fields)
{
	msql m(table, fields);
	m.Add(group, fields);

	TQuery q(str(m));
	return q.Read();
}

const char *check_exists(constant *tables, TGroup *group, const char *fields)
{
	constant *table;

	for (table = tables; *table; table++)
		if (check_exists(*table, group, fields))
			break;

	return *table;
}

sign check_pshell_md5sum(TWindow *parent, const char *name)
{
	static const unsigned char filler[48] =
	{
		0x0A, 0x89, 0x14, 0x9F, 0x11, 0x0C, 0xF0, 0xEB, 0x96, 0x6F, 0x71, 0xC1, 0x39, 0x14, 0x7C, 0x1D,
		0xBA, 0x98, 0x49, 0x22, 0x06, 0xA8, 0xE9, 0xCC, 0xFF, 0xE0, 0xED, 0x12, 0x5E, 0xF1, 0xA8, 0xA5,
		0x20, 0xA8, 0xE5, 0x03, 0xA4, 0x0C, 0x8C, 0xA1, 0xEC, 0x43, 0xE6, 0xD5, 0xB9, 0x19, 0x5E, 0x71
	};
	enum { SUM_OFFSET = 0x0D, SUM_SIZE = 16 };	// note: constant
	FILE *f;
	int size;
	char buffer[3072];
	unsigned char resBlock[SUM_SIZE];

	if ((f = fopen(name, "rb")) == NULL)
		return -1;

	size = fread(buffer, 1, sizeof buffer, f);
	fclose(f);

	if (size == -1)
		return -1;

	if (size < 1000 || size > 3000)
		return false;

	if (memcmp(buffer, "$checksum = '", SUM_OFFSET))
		return false;

	if (memcmp(buffer + sizeof filler - 3, "'\r\n", 3))
		return false;

	for (int i = 0, off = SUM_OFFSET; i < SUM_SIZE; i++, off += 2)
	{
		char xd[3] = { buffer[off], buffer[off + 1], '\0' };

		if (!isxdigit(xd[0]) || !isxdigit(xd[1]))
			return false;

		resBlock[i] = (unsigned char) strtol(xd, NULL, 0x10);
	}

	memcpy(buffer, filler, sizeof filler);

	int pad_size = SUM_SIZE - (size % SUM_SIZE);

	if (pad_size != SUM_SIZE)
	{
		memcpy(buffer + size, filler + (sizeof filler - SUM_SIZE) / 2, pad_size);
		size += pad_size;
	}

	memcpy(buffer + size, filler, sizeof filler);
	size += sizeof filler;

	unsigned char tResBlock[SUM_SIZE];

	calc_md5sum(buffer, size, (char *) tResBlock);
#if TESTVER
	if (memcmp(resBlock, tResBlock, SUM_SIZE))
	{
		mstr m;

		for (int i = 0; i < SUM_SIZE; i++)
			m.printf("%02X", tResBlock[i]);

		TLongTextDialog(parent, str(m)).Execute();
	}
#else  // TESTVER
	(void) parent;	
#endif  // TESTVER
	return !memcmp(resBlock, tResBlock, SUM_SIZE);
}

bool conteq(const TRCDKeyContainer *container1, const TRCDKeyContainer *container2)
{
	return container1->key == container2->key && container1->kind == container2->kind && container1->date == container2->date;
}

void copy_winds(const TRCDKeyContainer *source, TRCDKeyContainer *target, TWindData &windData, bool override)
{
	mstr involvements;
	msql m;

	{
		TBaseWind baseWind(windData.Name, NULL);

		baseWind.key = source->key;
		baseWind.kind = source->kind;
		baseWind.date = source->date;
		target->Involvements(involvements);
		baseWind.FloatCriteria(m);
	}

	TQuery q(str(m));
	while (q.Read())
	{
		windData << q;

		if (strmatch(windData.involvement, str(involvements)))
			windData.CopyTo(target, override);
	}
}

static bool filter_prefix(char *name, const char *pref)
{
	size_t len = strlen(pref);
	char *s = NULL;

	if (!strncmp(name, pref, len) && !isalpha(name[len]))
	{
		for (s = name + len; isspace(*s) || *s == '.'; s++);
		// 2009:105 memmove() -> strmove()
		strmove(name, s);
	}

	return s != NULL;
}

void filter_prefixes(char *target, const char *source, constant *prefixes)
{
	strcpy(target, source);

	for (constant *prefix = prefixes; *prefix; prefix++)
		if (filter_prefix(target, *prefix))
			break;
}

char find_college(const TRCDKeyContainer *container, TRCDKey *origin)
{
	TChar *tCollege = (TChar *) container->Find("F_COLLEGE");
	char college = tCollege ? tCollege->C() : '\0';
	TRCDKey tOrigin;

	if (!college && (origin || find_origin(container, *(origin = &tOrigin))))
	{
		// 2008:310 LPR: any [find_origin] type
		TRCDKeyContainer *container = type2RCDKeyContainer(origin->type);
		container->key = *origin;

		if (container->Get("F_COLLEGE"))
		{
			tCollege = (TChar *) container->Find("F_COLLEGE");
			college = tCollege->C();
		}

		delete container;
	}

	return college;
}

bool find_damn(const TLawsuit *lawsuit, TDamn *damn, bool complain)
{
	msql m(damn->Name);

	m.Add(lawsuit, "F_NO, F_YEAR, F_TYPE");
	TQuery q(str(m));

	if (q.Read())
	{
		*damn << q;
		return true;
	}
	else if (complain)
	{
		error("Ôèðìàòà çà %s %ld/%ldã. ëèïñâà èëè å íåäîñòúïíà.", Type->Seek(lawsuit->key.type),
			lawsuit->key.no, lawsuit->key.year);
	}

	return false;
}

bool find_finalizer(const TLawInterval &interval, TSession &session, const CDate &start, const CDate &final)
{
	if (!interval.finished.Empty() && (start != interval.finished || final != interval.finished) &&
		find_finalizer(interval, session, interval.finished, interval.finished))
	{
		return true;
	}

	// 2014:205 LPR: char array -> msql
	msql m(session.Name, "F_KIND, F_DATE, F_JUDGE, F_RESULT, F_FINAL");
	m.Add(&interval, "F_NO, F_YEAR, F_TYPE");

	if (start != DATE_MIN || final != DATE_MAX)
		m.AddRange("F_FINAL", start, final);
	else
		m.AddIsNull("F_FINAL", false);

	m.AddOrder("F_FINAL");
	TQuery q(str(m));

	if (q.Read())
	{
		session << q;
		session.key = interval.key;
		adjust_cancelaw(&session);
		return true;
	}

	return false;
}

bool find_finalizer(const TLawsuit *lawsuit, TSession &session, const CDate &start, const CDate &final)
{
	TLawInterval interval;

	interval.key = lawsuit->key;
	interval.finished = lawsuit->finished;
	return find_finalizer(interval, session, start, final);
}

TDecision *find_finalizer(const TSession &session, TGroupArray &decisions, const char *results)
{
	TDecision *result = NULL;
	int bestPriority = -1;

	if (!results)
		results = RESULT_CANCELAWS;

	try2decide(&session, &decisions, NULL, "F_KIND, F_RESULT, F_FROM_DATE, F_RETURNED");

	for (int i = 0; i < decisions.Count(); i++)
	{
		TDecision *decision = (TDecision *) decisions[i];
		int priority = 0;

	#if COURT_TYPE == COURT_REGIONAL
		if (strchr(KIND_PROTECTIONS, decision->kind))
			continue;
	#endif  // REGIONAL

		if (strchr(results, decision->result))
			priority |= 0x80;

		if (session.result == RESULT_PUBLIC_DECISION && public_decision(session.result, decision->kind))
			priority |= 0x40;

		priority |= 0x20 - strindex(KIND_ENDOCS, decision->kind);

		if (priority > bestPriority)
		{
			result = decision;
			bestPriority = priority;
		}
	}

	return result;
}

static bool word_boundary(const char *s)
{
	return !isalnum(s[-1]) || !isalnum(s[0]) || isalpha(s[-1]) != isalpha(s[0]);
}

bool find_words(const char *names, const char *uname, int words, long flags)
{
	if (!any(names))
		return true;

	int i = 0;
	const char *s = names;

	for (;;)
	{
		const char *p = strstr(uname, s);

		if (!p || (p > uname && !word_boundary(p)))
			break;

		if (!(flags & DEPART_EXTRA) && !word_boundary(p + strlen(s)))
			break;

		if (++i == words)
			return true;

		s += strlen(s) + 1;
	}

	return false;
}

bool find_origin(const TRCDKeyContainer *container, TRCDKey &origin)
{
	TInReg inReg;

	// 2010:063 LPR: FIX: was missing
	origin.type = TYPE_NULL;

	// 2009:141 LPR: FIX: support for optional inreg/outreg lawsuit key
	if (strchr(TYPE_ORIGINS, container->key.type))
		origin = container->key;
	else if (strchr(KIND_INREG_EVENTS, container->kind))
	{
		inReg.key = container->key;
		if (inReg.Get("F_LAWSUIT_NO, F_LAWSUIT_YEAR, F_LAWSUIT_TYPE"))
			origin = inReg.lawsuit.type ? inReg.lawsuit : container->key;
	}
	// 2010:053 SRQ: FIX: support for prove action
	else if (container->kind == KIND_PROVE_ACTION)
	{
		TProve prove;

		prove.key = container->key;

		if (prove.Get("F_LAWSUIT_NO, F_LAWSUIT_YEAR, F_LAWSUIT_TYPE"))
			origin = prove.lawsuit;
	}
	else if (container->Find("F_LAWSUIT_TYPE"))
	{
		origin.no = ((TLong *) container->Find("F_LAWSUIT_NO"))->L();
		origin.year = ((TLong *) container->Find("F_LAWSUIT_YEAR"))->L();
		origin.type = ((TChar *) container->Find("F_LAWSUIT_TYPE"))->C();

		if (!origin.type)
			origin = container->key;
		else if (origin.type == TYPE_INREG)
		{
			inReg.key = origin;
			if (inReg.Get("F_LAWSUIT_NO, F_LAWSUIT_YEAR, F_LAWSUIT_TYPE") && inReg.lawsuit.type)
				origin = inReg.lawsuit;
		}
	}
	else if (container->Find("F_DOC_TYPE"))
	{
		origin.no = ((TLong *) container->Find("F_DOC_NO"))->L();
		origin.year = ((TLong *) container->Find("F_DOC_YEAR"))->L();
		origin.type = ((TChar *) container->Find("F_DOC_TYPE"))->C();
	}
	else
	{
		return error("Unable to find origin for container %d/%d/%ld/%ld", container->key.type, container->kind,
			container->key.no, container->key.year);
	}

	// 2008:310 LPR: allow INREG and OUTREG, they can be origins
	if (origin.type && !strchr(TYPE_ORIGINS_INOUTS, origin.type))
		fatal("%d: type not supported by find_origin", origin.type);

	return origin.type;
}

static void full_side_list(mstr &m, TGArray<TSideWind> &sideWinds, char category, const char *categories, bool reNameInitial)
{
	for (int i = 0; i < sideWinds.Count(); i++)
		if ((categories ? categories[i] : sideWinds[i]->involvement) == category)
			add_side_name(m, sideWinds[i], ", ", reNameInitial);
}

void full_side_list(mstr &m, TGArray<TSideWind> *sideWinds, const char *categories, char category, bool reNameInitial)
{
	full_side_list(m, *sideWinds, category, categories, reNameInitial);
}

void full_side_list(mstr &m, TGArray<TSideWind> *sideWinds, char involvement, bool reNameInitial)
{
	full_side_list(m, *sideWinds, involvement, NULL, reNameInitial);
}

bool handle_restart(const TRCDKey &key, bool oldRestart, bool newRestart, const CDate &restartDate, bool firstSet)
{
	TLawInterval interval(key, restartDate);

	if (newRestart != oldRestart)
	{
		if (newRestart < oldRestart)
			interval.Delete(true);
		else
		{
			interval.flags |= LAW_INTERVAL_SECONDARY;
			interval.age = AGE_NONE_YET;
			interval.grant = GRANT_NONE_YET;

			if (firstSet)
				interval.firstSet = restartDate;

			// 2010:334 URQ: auto init finished
			// 2017:044 LPR: removed

			interval.Insert();
		}

		return true;
	}

	return false;
}

bool generate_max(const char *name, const char *s, long *data, long maximum, long year)
{
	long current;
	TGetGroup g(s, new TLong("MAX", &current));
	long next = current + 1;	// 2013:128 LPR

	// 2004:236 LPR: no check for maximum if there is no current
	if (*data)
	{
		// 2004:256 LPR/VRQ: administrators can enter anything
		if (*data > next && Default->post != POST_ADMIN)
		{
			// 2005:115 LRQ: anyone can enter anything for previous years
			if (year >= Today.year)
			{
				return error("%s: âúâåäåíèÿ íîìåð å ïðåêàëåíî ãîëÿì. "
					"Ìàêñèìàëíî äîïóñòèìèÿ íîìåð êúì ìîìåíòà å %ld.", name, next);
			}
			// 2013:071
			return ask("%s: íàé-ãîëåìèÿ âúâåäåí íîìåð äî ìîìåíòà å %ld. Æåëàåòå ëè äà ïðîäúëæèòå?", name, current);
		}
	}
	else if (next > maximum)
		return error("%s: äîñòèãíàò å íàé-ãîëåìèÿ íîìåð (%ld). Íåîáõîäèìî å ðú÷íî âúâåæäàíå íà íîìåð.", name, next);
	else
		*data = next;

	return true;
}

void generator_limit(const char *name)
{
	fatal("%s: generator reached limit", name);
}

void get_received_statuses(mstr &statuses, char receivedStatus, const TSubpoena *subpoena)
{
	if (strchr(SRS_INITIALS, receivedStatus))
		statuses.cach(receivedStatus);
	else if (subpoena)
		statuses.cach(subpoena->InitialStatus());
	else
		statuses.cach(SRS_FOR_DELIVER);

	statuses.cat(SRS_DELIV_BASICS);
}

void get_forty_fifty_stats(mstr &statuses, char type)
{
	if (type != TYPE_PUNISHMENT_LAW)
		statuses.cat(SRS_FORTY_FIFTY);
}

bool get_receiver(const TOutReg *outReg, TSender *sender)
{
	if (atob(outReg->receiver))
	{
		sender->ucnType = outReg->receiverType;
		strcpy(sender->ucn, outReg->receiver);
		return sender->Get();
	}

	return false;
}

const char *get_sencor_name(char ucnType, long court, mstr &m)
{
	TSender sender;
	msql w(sender.Name, "F_NAME");

	w.AddChar("F_UCN_TYPE", ucnType);
	w.AddLong("F_COURT", court);
	TQuery q(str(w));

	if (q.Read())
	{
		sender << q;
		m.cat(sender.name);
	}
	else if (court == COURT_CODE && ucnType != UCN_INSTANCE_SELF)
		return get_sencor_name(UCN_INSTANCE_SELF, court, m);
	else	// generic court name
		m.cat(Court->Seek(court));

	return str(m);
}

int load_connects(const char *criteria, TGArray<TConnect> *connects)
{
	TConnect connect;
	TQuery q(criteria);

	connect.LoadArray(connects, criteria);
	return connects->Count();
}

int load_connects(const TRCDKey &key, TGArray<TConnect> *connects)
{
	TConnect connect;
	msql m;

	connect.key = key;
	connect.FloatCriteria(m);
	return load_connects(str(m), connects);
}

void load_sidebasicv(TGArray<TSideWind> &sideWinds, const char *criteria, const char *extraUCNTypes)
{
	if (!extraUCNTypes)
		extraUCNTypes = "";

	TQuery q(criteria);
	while (q.Read())
	{
		TSideWind *sideWind = new TSideWind;
		*sideWind << q;

		if (strchr(UCN_REAL_SIDES, sideWind->ucnType) || strchr(extraUCNTypes, sideWind->ucnType))
			sideWinds.Add(sideWind);
		else	// 0.01%
			delete sideWind;
	}
}

void load_sidebasicv_criteria(msql &m, const TRCDKeyContainer *container)
{
	TSideWind sideWind;
	sideWind << container;
	sideWind.FloatCriteria(m, "F_UCN, F_UCN_TYPE, F_INVOLVEMENT, F_STATE, F_FROM_SIDE, F_FLAGS");
}

void load_sidebasicv(const TRCDKeyContainer *container, TGArray<TSideWind> &sideWinds)
{
	msql m;
	load_sidebasicv_criteria(m, container);
	load_sidebasicv(sideWinds, str(m));
}

char *load_categories(TRCDKeyContainer *container, TGArray<TSideWind> &sideWinds)
{
	char *categories = new char[sideWinds.Count()];

	for (int i = 0; i < sideWinds.Count(); i++)
	{
		TSideWind *sideWind = sideWinds[i];
		*sideWind << container;		// 2016:264 may break compat
		categories[i] = container->Category(sideWind->involvement);
	}

	return categories;
}

char *load_sidebasic(TRCDKeyContainer *container, TGArray<TSideWind> &sideWinds)
{
	load_sidebasicv(container, sideWinds);
	return load_categories(container, sideWinds);
}

void load_sidewinds(const TRCDKeyContainer *container, TGArray<TSideWind> *sideWinds)
{
	TSideWind sideWind;
	sideWind << container;
	sideWind.LoadFloat(sideWinds);
}

TGArray<TSideWind> *load_sidewinds(const TRCDKeyContainer *container)
{
	TSideWindArray *sideWinds = new TSideWindArray;
	load_sidewinds(container, sideWinds);
	return sideWinds;
}

TConnect *main_connect(const TRCDKeyContainer *container)
{
	TGArray<TConnect> connects;
	TConnect *connect = NULL;

	if (load_connects(container, &connects))
	{
		for (int i = 0; i < connects.Count(); i++)
		{
			if (strchr(CONNECT_TYPE_DECISIVES, connects[i]->connectType))
			{
				if (!connect)
				{
					connect = new TConnect;
					*connect << connects[i];
				}
				else
				{
					error(
						"%s %ld/%ldã. èìà 2+ îïðåäåëÿùè âèäà äåëà "
						"íà äðóãè èíñòèòóöèè/ñúäåáíè èíñòàíöèè!",
						Type->Seek(container->key.type),
						container->key.no,
						container->key.year
					);
					// 2007:025 LPR: return the 1st anyway
					//delete connect;
					//connect = NULL;
					break;
				}
			}
		}
	}

	return connect;
}

static char map_eispp(char letter)
{
	return "abvgdejiklmnprstufhczwyq"[strchr(EISPP_LETTERS, letter) - EISPP_LETTERS];
}

void map_eispp(char *base, int low, int high)
{
	for (int i = 0; i < 3; i++)
	{
		base[low + i] = map_eispp(base[low + i]);
		base[high + i] = map_eispp(base[high + i]);
	}
}

static wchar_t *lat2wide(const char *s)
{
	if (s)
	{
		wchar_t *ps = new wchar_t[strlen(s) + 1];
		wchar_t *ws = ps;

		do
			*ps++ = *s;
		while (*s++);

		return ws;
	}

	return NULL;
}

NET_API_STATUS net_validate_name(const char *server, const char *name, const char *account, const char *password,
	NETSETUP_NAME_TYPE NameType)
{
	wchar_t *wServer = lat2wide(server);
	wchar_t *wName = lat2wide(name);
	wchar_t *wAccount = lat2wide(account);
	wchar_t *wPassword = lat2wide(password);
	NET_API_STATUS status = NetValidateName(wServer, wName, wAccount, wPassword, NameType);

	delete[] wServer;
	delete[] wName;
	delete[] wAccount;
	delete[] wPassword;
	return status;
}

const char *obtain_deliverer(TGroupArray *deliverers, long uclp, long street, const char *adrNo, const char *blockNo)
{
	const char *deliverer = EMPTY;

	for (int i = 0; i < deliverers->Count(); i++)
	{
		TUserAliasGroup *user = (TUserAliasGroup *) (*deliverers)[i];

		if (user->Serves(uclp, street, adrNo, blockNo))
		{
			if (!strcmp(deliverer, EMPTY))
				deliverer = user->ucn;
			else
			{
				deliverer = EMPTY;
				break;
			}
		}
	}

	return deliverer;
}

void nearest_event_crit(msql &m, TRCDKeyContainer *container, bool forward, bool rejectSelf)
{
	m.AddLong("F_NO", container->key.no);
	m.AddLong("F_YEAR", container->key.year);
	m.AddChar("F_TYPE", container->key.type);
	m.Add("F_DATE");
	m.printf("%c= %ld", "<>"[forward], container->date.Value());

	if (rejectSelf)
	{
		m.AddChar("(NOT F_KIND", container->kind);
		m.NextOr();
		m.AddDate("NOT F_DATE", container->date);
		m.cat(")");
	}
}

TRCDKeyContainer *nearest_event_find(msql &m, TRCDKeyContainer *container, bool forward)
{
	TGSArray<TRCDKeyContainer> containers;	// full-course event sort

	m.AddOrder(forward ? "F_DATE" : "F_DATE DESC");
	TQuery q(str(m));

	while (q.Read())
	{
		TRCDKeyContainer *tContainer = kind2RCDKeyContainer(container->kind);

		*tContainer << q;
		tContainer->key = container->key;
		bool tc_leq = *tContainer <= *container;
		bool ct_leq = *container <= *tContainer;

		if (forward ? tc_leq && !ct_leq : ct_leq && !tc_leq)
		{
			delete tContainer;
			continue;
		}

		if (containers.Count() && tContainer->date != containers[0]->date)
		{
			delete tContainer;
			break;
		}

		containers.Add(tContainer);
	}

	return containers.Count() ? containers.Detach(forward ? 0 : containers.Count() - 1) : NULL;
}

TRCDKeyContainer *nearest_event_find(msql &m, TSideWind *sideWind, bool forward)
{
	TGSArray<TRCDKeyContainer> containers;	// full-course event sort
	TSideWind tSideWind;

	m.AddOrder(forward ? "F_DATE" : "F_DATE DESC");
	TQuery q(str(m));

	while (q.Read())
	{
		tSideWind << q;

		TRCDKeyContainer *tContainer = kind2RCDKeyContainer(tSideWind.kind);

		tContainer->key = sideWind->key;
		*tContainer << q;

		// speedup: closeds have empty time, and there may be many of them on single date
		if (tContainer->Find("F_TIME") && !strchr(KIND_CLOSED_SESSIONS, tContainer->kind))
			tContainer->Get("F_TIME");

		if (containers.Count() && tContainer->date != containers[0]->date)
		{
			delete tContainer;
			break;
		}

		containers.Add(tContainer);
	}

	return containers.Count() ? containers.Detach(forward ? 0 : containers.Count() - 1) : NULL;
}

void print_flags(mstr &m, const TFlagName *flagNames, long flags, const char *sep, const char *lead)
{
	size_t len = m.len();

	for (const TFlagName *fn = flagNames; fn->flag; fn++)
	{
		if (flags & fn->flag)
		{
			m.sep(sep);
			m.cat(fn->name);
		}
	}

	if (lead && m.len() > len)
		mbk_insert(&m, lead, len, strlen(lead));
}

void print_gps_link(mstr &m, double coordN, double coordE, const char *text)
{
#if TESTVER
	if (HTML_MAPS_FORMAT == 1)
	{
		m.printf("\v\aa href=\"http://maps.google.com/?q=%.14lf,%.14lf&z=%ld\"\b%s\a/a\b",
			coordN, coordE, HTML_MAPS_ZOOM, text);
	}
	else
	{
		m.printf("\v\aa href=\"http://www.google.com/maps/place/%.14lf,%.14lf/@%.14lf,%.14lf,%ldz",
			coordN, coordE, coordN, coordE, HTML_MAPS_ZOOM);

		if (HTML_MAPS_FORMAT == 2)
			m.cat("/data=!3m1!1e3");

		m.printf("\"\b%s\a/a\b", text);
	}
#else  // TESTVER
	if (!HTML_MAPS_FORMAT)
	{
		m.printf("\v\aa href=\"http://www.google.com/maps/place/%.14lf,%.14lf/@%.14lf,%.14lf,%ldz\"\b%s\a/a\b",
			coordN, coordE, coordN, coordE, HTML_MAPS_ZOOM, text);
	}
	else
	{
		m.printf("\v\aa href=\"http://maps.google.com/?q=%.14lf,%.14lf&z=%ld\"\b%s\a/a\b",
			coordN, coordE, HTML_MAPS_ZOOM, text);
	}
#endif  // TESTVER
}

void print_initials(mstr &m, const char *ucn, char ucnType, bool userFormat)
{
	TCitizen citizen;

	citizen.ucnType = ucnType;
	strcpy(citizen.ucn, ucn);

	if (citizen.Try())
	{
		if (userFormat)
			m.printf("%c%c", *citizen.name, *citizen.family);
		else
		{
			constant names[] = { citizen.name, citizen.reName, citizen.family, citizen.reFamily, NULL };

			for (constant *name = names; *name; name++)
				if (any(*name))
					m.printf("%c.", **name);
		}
	}
}

static void print_firm_char(mstr &m, const char *start, const char *s)
{
	bool wasalnum = isalnum(s[-1]);

	if (!isalnum(*s))
	{
		if (s == start || !isspace(*s) || !wasalnum)
			m.cach(*s);
	}
	else if (s == start || !wasalnum)
		m.printf("%c.", *s);
}

void print_firm_name(mstr &m, TUCNGroup *ucnGroup, bool filtered)
{
	TFirm firm;
	firm << ucnGroup;

	if (firm.Try())
	{
		size_t len = strlen(firm.name);
		bool printed = false;	// 2014:202 FIX: was using filtered

		if (filtered && strlen(firm.name) >= 4)
		{
			if (!memcmp(firm.name, "ÅÒ", 2) && !isalnum(firm.name[2]))
			{
				printed = true;
				m.catn(firm.name, 3);

				for (const char *s = firm.name + 3; *s; s++)
					print_firm_char(m, firm.name + 2, s);
			}
			else if (!memcmp(firm.name + len - 2, "ÅÒ", 2) && !isalnum(firm.name[len - 3]))
			{
				for (const char *s = firm.name; s[3]; s++)
					print_firm_char(m, firm.name, s);

				m.cat(firm.name + len - 3);
				printed = true;
			}
		}

		if (!printed)
			m.cat(firm.name);
	}
	else
		print_missing(m, ucnGroup->ucnType, ucnGroup->ucn);
}

void print_sender_name(mstr &m, TUCNGroup *ucnGroup)
{
	TSender sender;
	sender << ucnGroup;

	if (sender.Try())
	{
		if (strchr(UCN_LIST_NAMES_ONLY, ucnGroup->ucnType))
			m.cat(sender.name);
		else
			sender.Print(m);
	}
	else
		print_missing(m, ucnGroup->ucnType, ucnGroup->ucn);
}

void print_side_name(mstr &m, TUCNGroup *ucnGroup, bool reNameInitial)
{
	if (strchr(UCN_CITIZENS, ucnGroup->ucnType))
	{
		TCitizen citizen;
		citizen << ucnGroup;

		// 2008:071 LPR/LRQ: NAME R. FAMILY format
		if (citizen.Get())
		{
			m.printf("%s%s", citizen.Rank(), citizen.name);
			if (reNameInitial && strlen(citizen.reName) > 2)
				strcpy(citizen.reName + 1, ".");
			if (any(citizen.reName))
				m.printf(" %s", citizen.reName);
			m.printf(" %s", citizen.family);
		}
		else
			print_missing(m, ucnGroup->ucnType, ucnGroup->ucn);
	}
	else if (strchr(UCN_FIRMS, ucnGroup->ucnType))
		print_firm_name(m, ucnGroup);
	else if (ucn2uxn(ucnGroup->ucnType) == UXN_SENDER)
		print_sender_name(m, ucnGroup);
}

void print_side_wind(mstr &m, TUCNGroup *ucnGroup, bool filtered)
{
	if (strchr(UCN_CITIZENS, ucnGroup->ucnType))
	{
		if (filtered)
			print_initials(m, ucnGroup->ucn, ucnGroup->ucnType);
		else
			print_user(m, ucnGroup->ucn, ucnGroup->ucnType);
	}
	else if (strchr(UCN_FIRMS, ucnGroup->ucnType))
		print_firm_name(m, ucnGroup, filtered);
	else if (ucn2uxn(ucnGroup->ucnType) == UXN_SENDER)
		print_sender_name(m, ucnGroup);
}

void print_missing(mstr &m, char ucnType, const char *ucn)
{
	if (ucnType)
	{
		UCNType->ucnType = ucnType;

		if (UCNType->Try())
			m.printf(UCNType->name);
		else
			m.printf("%03d", ucnType);
	}

	m.printf(" %s", any(ucn) ? ucnType == UCN_CITIZEN_UCN ? "..." : ucn : "??");
}

void print_name(mstr &m, const char *ucn, char ucnType)
{
	if (ucn2uxn(ucnType) == UXN_SENDER)
	{
		TSender sender;

		sender.ucnType = ucnType;
		strcpy(sender.ucn, ucn);

		if (sender.Get("F_NAME"))
			m.cat(sender.name);
		else
			print_missing(m, ucnType, ucn);
	}
	else
	{
		TSideWind sideWind;

		sideWind.ucnType = ucnType;
		strcpy(sideWind.ucn, ucn);
		sideWind.PrintNames(m);
	}
}

bool print_postal(mstr &m, long flags, long flagsX)
{
	char *s;

	switch (flags & OUTREG_POSTAL)
	{
		case OUTREG_REGULAR : s = "îáèêí. ïèñìî"; break;
		case OUTREG_R : s = "ïðåïîðú÷àíî"; break;
		case OUTREG_AR : s = "ïðåïîðú÷àíî ñ îáð. ðàçïèñêà"; break;
		case OUTREG_PACKAGE : s = "êîëåò"; break;
		default : s = NULL;
	}

	if (s)
		m.printf("ïî ïîùàòà - %s", s);

	struct TFlagText
	{
		long flag;
		char *text;
	};

	static const TFlagText FlagTexts[] =
	{
		{ OUTREG_X_COURIER, "ïî êóðèåð" },
		{ OUTREG_X_FAX,     "ïî ôàêñ" },
		{ OUTREG_X_EMAIL,   "ïî åëåêòðîííà ïîùà" },
		{ OUTREG_NONE,	NULL }
	};

	for (const TFlagText *ft = FlagTexts; ft->flag; ft++)
	{
		if (flagsX & ft->flag)
		{
			if (s)
				m.cat(", ");
			else
				s = "";
			m.cat(ft->text);
		}
	}

	return s;
}

void print_received(mstr &m, char status, const CDate &received, const CTime &receivedTime, double coordN, double coordE)
{
	mstr text;

	ReceivedStatus->Seek(status);
	text.cat(ReceivedStatus->alias);

	if (ReceivedStatus->AllowDateReceived())
	{
		received.Print(text, " íà %D");
		receivedTime.Print(text, " %T÷.");

		if (received.Empty() || coordN == 0.0)
			m.cat(text);
		else
			print_gps_link(m, coordN, coordE, str(text));
	}
	else	// 2016:322 TRQ: FIX: show status
		m.cat(text);
}

const char *send_type(const TOutReg *outReg)
{
	const char *s;

	switch (outReg->receiverType)
	{
		case UCN_INSTANCE_HIGHER : s = "èçïðàùàíå çà îáæàëâàíå"; break;
		case UCN_INSTANCE_LOWER : s = "âðúùàíå â I-èíñò. ñúä"; break;
		case UCN_INSTANCE_EQUAL : s = "èçïðàùàíå ïî ïîäñúäíîñò"; break;
		case UCN_INSTANCE_CONFLICT : s = "èçïðàùàíå çà îïðåäåëÿíå íà êîìïåòåíòåí ñúä"; break;
		case UCN_INSTANCE_COMPETENT : s = "èçïðàùàíå ïî êîìïåòåíòíîñò"; break;
		case UCN_INSTANCE_PROSEC : s = "âðúùàíå çà äîðàçñëåäâàíå"; break;
		default : s = NULL;
	}

	return s;
}

void print_send(mstr &m, const TOutReg *outReg)
{
	const char *s = send_type(outReg);

	if (s)
		m.cpy(s);

	if (print_postal(m, outReg) && s)
		mbk_insert(&m, ", ", strlen(s), 2);
}

void print_sfor(mstr &m, const TRCDKeyContainer *container)
{
	char name[SIZE_OF_NAME];	// 2007:240 LRQ: +related
	TBaseString *text = (TString *) container->Find("F_TEXT");

	if (strchr(KIND_ANY_OTHER_DOCUMENTS, container->kind) && text && *text->S())
		strzcpy(name, text->S(), sizeof name);
	else
		strcpy(name, Kind->Seek(container->kind));

	m.printf("%-40s  %-D  %5ld/%4ld", name, &container->date, container->key.no, container->key.year);
}

void print_user(char *s, const TCitizenNames *names, bool rank, sign reFamily)
{
	strcpy(s, rank ? names->Rank() : "");

	if (reFamily == -1 && strlen(names->name) >= 2)
		scprintf(s, "%c.", *names->name);
	else
		strcat(s, names->name);

	if (any(names->reName))
	{
		if (strlen(names->reName) <= 2)
			scprintf(s, " %s", names->reName);
		else
			scprintf(s, " %c.", *names->reName);
	}

	scprintf(s, " %s", names->family);

	if (reFamily && any(names->reFamily))
		scprintf(s, "%c%s", reFamily == true ? ' ' : '-', names->reFamily);
}

void print_user(char *s, const char *ucn, char ucnType, bool rank, sign reFamily)
{
	TCitizen citizen;

	strcpy(citizen.ucn, ucn);
	citizen.ucnType = ucnType;

	if (citizen.Try())
	{
		// 2015:080 handle INTER
		if (!strcmp(citizen.ucn, INTER) && ucnType == UCN_CITIZEN_UCN)
			sprintf(s, "%s %s", citizen.name, citizen.family);
		else
			print_user(s, &citizen, rank, reFamily);
	}
	else
	{
		mstr m;
		print_missing(m, ucnType, ucn);
		strcpy(s, str(m));
	}
}

void print_user(mstr &m, const TCitizenNames *names, bool rank, sign reFamily)
{
	char s[SIZE_OF_USER_NAME];
	print_user(s, names, rank, reFamily);
	m.cat(s);
}

void print_user(mstr &m, const char *ucn, char ucnType, bool rank, sign reFamily)
{
	char s[SIZE_OF_USER_NAME];
	print_user(s, ucn, ucnType, rank, reFamily);
	m.cat(s);
}

void remove_file(const char *name, const char *what, sign remove)
{
	// 2015:091 IRQ/TRQ: 7even returns EACCES
	if ((remove == true || (remove == -1 && exist(name))) && unlink(name) && errno != EACCES)
		error(what ? "%s: ãðåøêà %d ïðè èçòðèâàíå íà %s." : "%s: ãðåøêà %d ïðè èçòðèâàíå.", name, errno, what);
}

const char *rrseek(char type, char status)
{
#if COURT_TYPE == COURT_APPEAL || COURT_TYPE == COURT_AREAL || COURT_TYPE == COURT_MILITARY || COURT_TYPE == COURT_REGIONAL
	return type == TYPE_PROVE || type == TYPE_REQUEST ? Resolution->Seek(status) : Result->Seek(status);
#endif  // APPEAL || AREAL || MILITARY || REGIONAL
#if COURT_TYPE == COURT_ADMIN
	return type == TYPE_REQUEST ? Resolution->Seek(status) : Result->Seek(status);
#endif  // ADMIN
}

void surrouendoc_text(mstr &m, const TSurroundment *surrouendoc)
{
	bool surrounded = false;

	if (strchr(KIND_TEXTUAL_SURROUNDS, surrouendoc->kind))
	{
		TSurround surround;
		surround.key = surrouendoc->key;

		if (surround.Try("F_TEXT") && any(surround.text))
		{
			m.cat(surround.text);
			surrounded = true;
		}
	}

	if (!surrounded)
		m.cat(Kind->Seek(surrouendoc->kind));
}

bool say_cant_delete()
{
	return error("Äàííèòå ñà íåîáõîäèìè çà íîðìàëíàòà ðàáîòà íà ïðîãðàìàòà è íå ìîãàò äà áúäàò èçòðèòè.");
}

bool say_cant_update()
{
	return error("Äàííèòå ñà íåîáõîäèìè çà íîðìàëíàòà ðàáîòà íà ïðîãðàìàòà è íå ìîãàò äà áúäàò ðåäàêòèðàíè.");
}

constant MISSING_DATA = "ëèïñâàùè â áàçàòà, íåïîïúëíåíè èëè áëîêèðàíè îò äðóã ïîòðåáèòåë äàííè";

bool say_no_data(const char *name)
{
	return error("%s: %s.", name, MISSING_DATA);
}

bool say_no_selection()
{
	return error("Íå å èçáðàí åëåìåíò.");
}

bool secondary(char lawsuitKind)
{
#if COURT_TYPE == COURT_APPEAL
	(void) lawsuitKind;
	return true;
#endif  // APPEAL
#if COURT_TYPE == COURT_ADMIN || COURT_TYPE == COURT_AREAL || COURT_TYPE == COURT_MILITARY
	return strchr(KIND_2ND_LAWSUITS, lawsuitKind);
#endif  // ADMIN || AREAL || MILITARY
#if COURT_TYPE == COURT_REGIONAL
	(void) lawsuitKind;
	return false;
#endif  // REGIONAL
}

unsigned split_words(char *names, const char *spaces)
{
	unsigned words;

	compress(names, spaces);
	words = any(names);

	for (char *s = names; (s = strchr(s, ' ')) != NULL; s++)
	{
		*s = '\0';
		words++;
	}

	return words;
}


double round(double d, int nDec)
{
	double factor = 1.0;

	for (int i = 0; i < nDec; i++)
		factor *= 10.0;

	d *= factor;

	return (d - floor(d) >= 0.5 ? ceil(d) : floor(d)) / factor;
}

double uround(double d)
{
	mstr m;
	m.printf("%.0lf", d);
	return atof(str(m));
}

void schedule(char sched, TRCDKeyContainer *container, const CDate *start, const CDate *final, const char *judge)
{
	// 2003:059 judge support; 2009:216 LPR: FAKE/ACTIVE check moved to top
	if ((judge && !strcmp(judge, INTER)) || sched == SCHED_FAKE || !SCHED_ACTIVE)
		return;

	TRCDKey origin;
	CalInterval->calInterval = sched;

	if (find_origin(container, origin) && strchr(TYPE_ORIGINS, origin.type) && CalInterval->Get())
	{
		TSched tSched;

		tSched << container;
		tSched.lawsuit = origin;

		tSched.sched = sched;
		tSched.start = *start;
		tSched.final = *(final ? final : start);
		tSched.final.Advance(CalInterval->interval, CalInterval->count, CalInterval->delta);

		// 2003:064; 2003:079 BUGFIX: judge was copied from <<
		strcpy(tSched.judge, judge && atob(judge) ? judge : "");
		tSched.Insert();
	}
}

void transliterate(const char *src, char *dst, size_t maxlen)
{
	static const char *const translit[32] =
	{
		"A", "B", "V", "G", "D", "E", "ZH", "Z", "I", "Y", "K", "L", "M", "N", "O", "P",
		"R", "S", "T", "U", "F", "H", "TS", "CH", "SH", "SHT", "A", "YI", "Y", "E", "YU", "YA"
	};

	*dst = '\0';

	for (const char *s = src; *s && strlen(dst) < maxlen; s++)
	{
		char c = *s;

		if ((c & 0xC0) == 0xC0)
		{
			if (tolower(c) == 'ÿ' && s > src && tolower(s[-1]) == 'è' && !isalpha(s[1]))
				c -= (char) ('ÿ' - 'à');	// keep upper-lower

			const char *trans = translit[c & 0x1F];
			size_t dlen = strlen(dst);

			if (dlen + strlen(trans) > maxlen)
				break;

			strcat(dst, trans);

			if ((c & 0xE0) == 0xE0)
				strlwr(dst + dlen);
			else if (islower(s[1]))
				strlwr(dst + dlen + 1);
		}
		else
			strcat(dst, C2S[c]);
	}
}

void unschedule(char sched, TRCDKeyContainer *container)
{
	if (sched != SCHED_FAKE)
	{
		TSched tSched;

		tSched << container;
		tSched.sched = sched;
		tSched.Delete(sched != SCHED_NULL);
	}
}

void unschedule(char sched, TLawsuit *lawsuit)
{
	if (sched != SCHED_FAKE)
	{
		TSched tSched;

		if (sched != SCHED_NULL)
		{
			msql m(tSched.Name, MQ_DELETE);

			m.AddLong("F_LAWSUIT_NO", lawsuit->key.no);
			m.AddLong("F_LAWSUIT_YEAR", lawsuit->key.year);
			m.AddChar("F_LAWSUIT_TYPE", lawsuit->key.type);
			m.AddChar("F_SCHED", sched);
			tSched.DataBase->Execute(str(m), ET_ERROR);
		}
		else
		{
			tSched << lawsuit;
			tSched.Delete(false);
		}
	}
}

void unschedule(char sched, TInReg *inReg)
{
	if (sched != SCHED_FAKE)
	{
		TSched tSched;
		msql m(tSched.Name, MQ_DELETE);

		m.Add(inReg, "F_NO, F_YEAR, F_TYPE");

		if (sched != SCHED_NULL)
			m.AddChar("F_SCHED", sched);

		tSched.DataBase->Execute(str(m), ET_ERROR);
	}
}

static void log(char gop, long opc, const TRCDKeyContainer *container, TConnect *connect)
{
	mstr m;
	connect->Print(m);
	log(gop, opc, container, str(m));
}

bool write_connects(const TRCDKeyContainer *container, TGArray<TConnect> *connects, char *what)
{
	TGArray<TConnect> tConnects;
	bool cosync = true;
	bool comain = true;
	int oldi, newi;
	bool saved[CONNECT_TYPES_MAX];	// 2008:063 was: SIZE_OF_CONNECT_TYPES

	memset(saved, 0, sizeof saved);
	load_connects(container, &tConnects);

	for (oldi = 0; oldi < tConnects.Count(); oldi++)
	{
		for (newi = 0; newi < connects->Count(); newi++)
			if (tConnects[oldi]->connectType == (*connects)[newi]->connectType)
				break;

		if (newi < connects->Count())
		{
			TConnect *connect = (*connects)[newi];

			if (connect->dirty)
			{
				connect->key = container->key;

				if (connect->Update())
					log(LOG_EDIT, IDEDIT, container, connect);
				else
				{
					cosync = false;
					if (strchr(CONNECT_TYPE_DECISIVES, connect->connectType))
						comain = false;
				}
			}
			saved[newi] = true;
		}
		else
		{
			if (tConnects[oldi]->Delete(true))
				log(LOG_DELETE, IDDELETE, container, tConnects[oldi]);
			else
			{
				cosync = false;
				if (strchr(CONNECT_TYPE_DECISIVES, (*connects)[newi]->connectType))
					comain = false;
			}
		}
	}

	for (newi = 0; newi < connects->Count(); newi++)
	{
		if (!saved[newi])
		{
			(*connects)[newi]->key = container->key;
			if ((*connects)[newi]->Insert())
				log(LOG_ADD, IDADD, container, (*connects)[newi]);
			else
			{
				cosync = false;
				if (strchr(CONNECT_TYPE_DECISIVES, (*connects)[newi]->connectType))
					comain = false;
			}
		}
	}

	if (what && !cosync)
		error(!comain
			? "Îïðåäåëÿùîòî ñëóæåáíî äåëî/äîêóìåíò íå ñå çàïèñà! Ðåäàêòèðàéòå %s."
			: "Íå ñå çàïèñà ïúëíèÿò ñïèñúê ñëóæåáíè äåëà/äîêóìåíòè! Ðåäàêòèðàéòå %s.",
			what
		);

	return cosync;
}
